import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { store } from './store';
import { fetchPlayers } from '../api/playersAPI';
import { Player } from '../types/Player';

export interface PlayersStateProps {
  players: {
    [key: number] : Player;
  };
  filteredPlayers:{
    [key: number] : Player;
  };
  favoritePlayers: {
    [key: number] : Player;
  };
  currentMeta?: any;
  newMeta?: any;
  status: 'idle' | 'loading' | 'failed';
  error: any;
}

const initialState: PlayersStateProps = {
  players: {},
  filteredPlayers: {},
  favoritePlayers: {},
  currentMeta: {},
  newMeta: {},
  status: 'idle',
  error: null,
};

export const playersSlice = createSlice({
  name: 'players',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setPlayers: (state, action: PayloadAction<any>) => {
      state.players = {
        ...action.payload.reduce((acc: any, player: any) => {
          if (player.id in state.favoritePlayers) {
            return acc;
          }
          acc[player.id] = player;
          return acc;
        }, {})
      };
    },
    addToFavorites: (state, action: PayloadAction<Player>) => {
      state.favoritePlayers[action.payload.id] = action.payload;
      // remove from players list
      delete state.players[action.payload.id];
    },
    removeFromFavorites: (state, action: PayloadAction<Player>) => {
      delete state.favoritePlayers[action.payload.id];
    },
    setMeta: (state, action: PayloadAction<any>) => {
      state.currentMeta = action.payload;
    },
    setNewMeta: (state, action: PayloadAction<any>) => {
      state.newMeta = action.payload;
    },
    resetError: (state) => {
      state.status = 'idle';
      state.error = null;
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetch.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetch.fulfilled, (state, action) => {
        state.status = 'idle';
      })
      .addCase(fetch.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error;
      });
  },
});

export const { setPlayers, addToFavorites, removeFromFavorites, setMeta, setNewMeta, resetError } = playersSlice.actions;

// The function below is called a thunk and allows us to perform async logic. this one is for fetching players
export const fetch = createAsyncThunk(
  'players/fetch',
  async (args: any) => {
    const { search, newMeta } = args;
    const response = (!!search) ? await fetchPlayers(search, newMeta) : await fetchPlayers(undefined, newMeta);
    // The value we return becomes the `fulfilled` action payload
    store.dispatch(setPlayers(response?.data));
    store.dispatch(setMeta(response?.meta))
    return response;
  }
);

export default playersSlice.reducer;
